# 4.4.3 Exemplo prático

Para entender como os escopos funcionam na prática, vamos observar uma situação concreta envolvendo diferentes configurações do git. A ideia é acompanhar o que o git mostra no terminal, como ele lê todos os arquivos de configuração disponíveis e como decide qual valor utilizar em cada contexto.

#### Contexto

Imagine que uma pessoa esteja trabalhando em um computador com Linux, onde o git já está instalado. O nome da pessoa usuária do sistema é `aprendiz`.

Ela abre o terminal e entra em um repositório git localizado em:

```
/home/aprendiz/projeto
```

Antes de qualquer alteração, ela decide observar quais configurações existem e como o git as enxerga naquele momento.

#### Listando todas as configurações visíveis

Ao listar as configurações, o git exibe algo como:

```bash
$ git config --list
color.ui=true
user.name=Aprendiz Cumbuca Dev
user.email=aprendiz.cumbucadev@gmail.com
core.editor=code --wait
user.name=Aprendiz Projeto X
user.email=projeto.x@email.com
```

Essa saída não mostra apenas o valor ativo. Ela lista todas as configurações que o git consegue enxergar, vindas de todos os escopos disponíveis.

Por isso, a mesma chave pode aparecer mais de uma vez, associada a valores diferentes.

Não se preocupe com as configurações `core.editor` e `color.ui`. Elas aparecem aqui apenas para ilustrar que o git lê várias configurações ao mesmo tempo.

Neste ponto, ainda não é possível saber de qual arquivo cada valor vem nem qual valor será efetivamente utilizado. Para isso, é preciso observar a origem das configurações.

#### Visualizando a origem das configurações

Ao listar novamente usando a opção `--show-origin`, o git mostra:

```bash
$ git config --list --show-origin
file:/etc/gitconfig                     color.ui=true
file:/home/aprendiz/.gitconfig          user.name=Aprendiz Cumbuca Dev
file:/home/aprendiz/.gitconfig          user.email=aprendiz.cumbucadev@gmail.com
file:/home/aprendiz/.gitconfig          core.editor=code --wait
file:/home/aprendiz/projeto/.git/config user.name=Aprendiz Projeto X
file:/home/aprendiz/projeto/.git/config user.email=projeto.x@email.com
```

Essa saída deixa claro que:

* `color.ui` foi definida no escopo system, no arquivo `/etc/gitconfig`
* `user.name`, `user.email` e `core.editor` foram definidas no escopo global, no arquivo `/home/aprendiz/.gitconfig`
* `user.name` e `user.email` foram definidas novamente, com outros valores, no escopo local, no arquivo `/home/aprendiz/projeto/.git/config`

O git não elimina duplicatas ao listar. Ele mostra tudo o que encontrou ao percorrer os arquivos de configuração disponíveis.

#### Descobrindo qual valor é realmente utilizado

Para saber qual valor o git realmente utiliza, é preciso consultar a configuração diretamente.

Ao consultar `user.name`, o git retorna:

```bash
$ git config user.name
Aprendiz Projeto X
```

Esse é o valor ativo, escolhido após o git aplicar a ordem de prioridade entre os escopos. Mesmo existindo um valor no escopo global, o valor do escopo local vence por ser mais específico.

O mesmo acontece com `user.email`:

```bash
$ git config user.email
projeto.x@email.com
```

Aqui fica clara a diferença fundamental entre os comandos:

* `git config --list` mostra tudo o que o git encontrou
* `git config <chave>` mostra apenas o valor efetivamente utilizado

#### Saindo do repositório e mudando o contexto do git

Até aqui, todas as observações foram feitas dentro do repositório `/home/aprendiz/projeto`. Nesse contexto, o escopo local existe e é considerado pelo git.

Agora, imagine que a pessoa sai desse repositório e volta para o diretório pessoal:

```bash
$ cd /home/aprendiz
```

Neste momento, o git não está mais dentro de um repositório. Isso muda quais escopos estão disponíveis.

Ao listar as configurações fora do repositório, o git exibe:

```bash
$ git config --list
color.ui=true
user.name=Aprendiz Cumbuca Dev
user.email=aprendiz.cumbucadev@gmail.com
core.editor=code --wait
```

Note que `user.name=Aprendiz Projeto X` e `user.email=projeto.x@email.com` não aparecem aqui.

Essas configurações continuam existindo no arquivo:

```
/home/aprendiz/projeto/.git/config
```

Elas apenas não são consideradas, porque o escopo local só existe quando o git está dentro daquele repositório.

Ao verificar a origem:

```bash
$ git config --list --show-origin
file:/etc/gitconfig                     color.ui=true
file:/home/aprendiz/.gitconfig          user.name=Aprendiz Cumbuca Dev
file:/home/aprendiz/.gitconfig          user.email=aprendiz.cumbucadev@gmail.com
file:/home/aprendiz/.gitconfig          core.editor=code --wait
```

Agora, o git lê apenas os escopos global e system.

Ao consultar `user.name` nesse contexto:

```bash
$ git config user.name
Aprendiz Cumbuca Dev
```

O valor retornado é o do escopo global. O valor local não participa da decisão, mesmo ainda estando gravado no projeto.

#### Alterando configurações locais e observando o impacto

A pessoa então retorna para o repositório:

```bash
$ cd /home/aprendiz/projeto
```

Em seguida, altera o valor de `user.name` no escopo _local_ usando o comando:

```bash
$ git config user.name "Aprendiz do grande Projeto X"
```

Após essa alteração, a listagem com origem passa a mostrar:

```bash
$ git config --list --show-origin
file:/etc/gitconfig                     color.ui=true
file:/home/aprendiz/.gitconfig          user.name=Aprendiz Cumbuca Dev
file:/home/aprendiz/.gitconfig          user.email=aprendiz.cumbucadev@gmail.com
file:/home/aprendiz/.gitconfig          core.editor=code --wait
file:/home/aprendiz/projeto/.git/config user.name=Aprendiz do grande Projeto X
file:/home/aprendiz/projeto/.git/config user.email=projeto.x@email.com
```

Ao consultar novamente:

```bash
$ git config user.name
Aprendiz do grande Projeto X
```

O valor ativo muda imediatamente. Apenas o arquivo do escopo _local_ foi alterado.

#### Removendo configurações locais

Em um momento seguinte, as configurações locais são removidas explicitamente com os comandos:

```bash
$ git config --unset user.name
$ git config --unset user.email
```

Após isso, a listagem mostra:

```bash
$ git config --list --show-origin
file:/etc/gitconfig                     color.ui=true
file:/home/aprendiz/.gitconfig          user.name=Aprendiz Cumbuca Dev
file:/home/aprendiz/.gitconfig          user.email=aprendiz.cumbucadev@gmail.com
file:/home/aprendiz/.gitconfig          core.editor=code --wait
```

Ao consultar novamente:

```bash
$ git config user.name
Aprendiz Cumbuca Dev
```

O git passa a utilizar o valor do escopo global, que agora é o mais específico disponível.

#### Removendo também as configurações globais

Por fim, as configurações globais são removidas explicitamente:

```bash
$ git config --global --unset user.name
$ git config --global --unset user.email
```

A listagem passa a mostrar apenas:

```bash
$ git config --list --show-origin
file:/etc/gitconfig color.ui=true
```

Ao consultar `user.name`:

```bash
$ git config user.name
```

Nenhum valor é retornado. Isso indica que essa configuração não está definida em nenhum escopo.

***

Observando a sequência completa desse exemplo, temos que:

* <mark style="color:purple;">git</mark> <mark style="color:orange;">config</mark> <mark style="color:blue;">--list</mark> lista todas as configurações encontradas
* chaves podem aparecer repetidas com valores diferentes
* o _Git_ só escolhe um valor no momento da consulta
* a prioridade entre escopos só é aplicada ao usar a configuração
* <mark style="color:blue;">--show-origin</mark> revela exatamente quais arquivos estão sendo lidos
* o escopo local só existe quando o git está dentro de um repositório

Na próxima seção, veremos como essas configurações aparecem naturalmente no uso cotidiano do git e por que elas são necessárias logo nos primeiros passos ao trabalhar com a ferramenta.
